<!DOCTYPE html>


<!-- Ultimate Game Stash file--> 
<!-- For the regularly updating doc go to https://docs.google.com/document/d/1_FmH3BlSBQI7FGgAQL59-ZPe8eCxs35wel6JUyVaG8Q/ -->


<html lang="en-us">
<head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Die in the Dungeon</title>

    <base href="https://cdn.jsdelivr.net/gh/bubbls/UGS-Assets@main/die%20in%20the%20dungeon/"> 

    <style>
        html, body {
            width: 100%; 
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
        }

        #gameContainer {
            width: 100% !important;
            height: 100% !important;
            position: absolute;
            top: 0;
            left: 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #gameContainer canvas {
            width: 100% !important;
            height: 100% !important;
            display: block;
        }
    </style>

    <script>
      window.fileMergerConfig = {
        files: [
          // Ensure your files on GitHub are named:
          // Die in the Dungeon 1.6.2f [WEB].data.gz.part1
          // Die in the Dungeon 1.6.2f [WEB].data.gz.part2
          { name: 'Die in the Dungeon 1.6.2f [WEB].data.gz', parts: 2 },
          
          // Die in the Dungeon 1.6.2f [WEB].wasm.gz.part1
          // Die in the Dungeon 1.6.2f [WEB].wasm.gz.part2
          { name: 'Die in the Dungeon 1.6.2f [WEB].wasm.gz', parts: 2 },
        ],
        basePath: 'Build/', 
        debug: true
      };  
    </script>

    <script>
    (function() {
      'use strict';
      const defaultConfig = { files: [], basePath: '', debug: true };
      const config = Object.assign({}, defaultConfig, window.fileMergerConfig || {});
      window.mergedFiles = window.mergedFiles || {};
      const mergeStatus = {};

      function log(...args) { if (config.debug) console.log('[FileMerger]', ...args); }
      function error(...args) { console.error('[FileMerger]', ...args); }
      
      function normalizeUrl(url) { 
          try { return decodeURIComponent(url.toString().split('?')[0]); } catch (e) { return url; } 
      }
      
      function urlsMatch(url1, url2) {
        const norm1 = normalizeUrl(url1); const norm2 = normalizeUrl(url2);
        if (norm1 === norm2) return true;
        if (norm1.endsWith(norm2) || norm2.endsWith(norm1)) return true;
        return norm1.split('/').pop() === norm2.split('/').pop();
      }

      async function mergeSplitFiles(filePath, numParts) {
        try {
          const parts = [];
          for (let i = 1; i <= numParts; i++) parts.push(`${filePath}.part${i}`);
          log(`Merging ${filePath} from ${numParts} parts...`);
          
          // We must encode the URL because of the spaces in "Die in the Dungeon"
          const encodedParts = parts.map(p => encodeURI(p));
          
          const responses = await Promise.all(encodedParts.map(part => window.originalFetch(part)));
          for (let i = 0; i < responses.length; i++) {
            if (!responses[i].ok) throw new Error(`Failed to load ${parts[i]}: ${responses[i].status}`);
          }
          const buffers = await Promise.all(responses.map(r => r.arrayBuffer()));
          const totalSize = buffers.reduce((sum, buf) => sum + buf.byteLength, 0);
          const mergedArray = new Uint8Array(totalSize);
          let offset = 0;
          for (const buffer of buffers) {
            mergedArray.set(new Uint8Array(buffer), offset);
            offset += buffer.byteLength;
          }
          log(`âœ… ${filePath} merged (${(totalSize/1024/1024).toFixed(2)} MB)`);
          return mergedArray.buffer;
        } catch (err) {
          error(`Failed to merge ${filePath}:`, err);
          throw err;
        }
      }

      function shouldInterceptFile(url) {
        const urlStr = normalizeUrl(url);
        if (urlStr.includes('.part')) return null;
        for (const file of config.files) {
          const fileName = file.name;
          const fullPath = config.basePath ? `${config.basePath}${fileName}` : fileName;
          if (urlsMatch(urlStr, fileName) || urlsMatch(urlStr, fullPath)) return fileName;
        }
        return null;
      }

      function getMergedFile(filename) {
        if (window.mergedFiles[filename]) return window.mergedFiles[filename];
        for (const [key, value] of Object.entries(window.mergedFiles)) {
          if (urlsMatch(key, filename)) return value;
        }
        return null;
      }

      if (!window.originalFetch) window.originalFetch = window.fetch;
      window.fetch = function(url, ...args) {
        const filename = shouldInterceptFile(url);
        if (filename) {
          log('Intercepting fetch:', filename);
          return new Promise((resolve, reject) => {
            const check = setInterval(() => {
              const buffer = getMergedFile(filename);
              if (buffer) {
                clearInterval(check);
                resolve(new Response(buffer, { 
                    status: 200, 
                    headers: { 'Content-Type': filename.endsWith('wasm.gz') ? 'application/wasm' : 'application/octet-stream' }
                }));
              } else if (mergeStatus[filename] === 'failed') {
                clearInterval(check); reject(new Error('Merge failed'));
              }
            }, 100);
          });
        }
        return window.originalFetch.call(this, url, ...args);
      };

      if (!window.OriginalXMLHttpRequest) window.OriginalXMLHttpRequest = window.XMLHttpRequest;
      window.XMLHttpRequest = function(options) {
        const xhr = new window.OriginalXMLHttpRequest(options);
        const originalOpen = xhr.open;
        const originalSend = xhr.send;
        let requestUrl = '';
        xhr.open = function(method, url, ...args) {
          requestUrl = url;
          return originalOpen.call(this, method, url, ...args);
        };
        xhr.send = function(...args) {
          const filename = shouldInterceptFile(requestUrl);
          if (filename) {
            log('Intercepting XHR:', filename);
            const waitForMerge = () => {
              const buffer = getMergedFile(filename);
              if (buffer) {
                Object.defineProperties(xhr, {
                  status: { value: 200 },
                  response: { value: buffer },
                  readyState: { value: 4 }
                });
                setTimeout(() => {
                   if(xhr.onreadystatechange) xhr.onreadystatechange();
                   if(xhr.onload) xhr.onload({ type: 'load', target: xhr });
                }, 10);
              } else if (mergeStatus[filename] === 'failed') {
                 if(xhr.onerror) xhr.onerror(new Error('Merge failed'));
              } else { setTimeout(waitForMerge, 100); }
            };
            waitForMerge();
            return;
          }
          return originalSend.call(this, ...args);
        };
        return xhr;
      };

      async function autoMergeFiles() {
        if (!config.files.length) return;
        config.files.forEach(file => {
          const fullPath = config.basePath ? `${config.basePath}${file.name}` : file.name;
          mergeStatus[file.name] = 'merging';
          mergeSplitFiles(fullPath, file.parts).then(buffer => {
            window.mergedFiles[file.name] = buffer;
            window.mergedFiles[fullPath] = buffer;
            mergeStatus[file.name] = 'ready';
          }).catch(() => mergeStatus[file.name] = 'failed');
        });
      }
      autoMergeFiles();
    })();
    </script>
</head>

<body>
  <div id="gameContainer">
    <canvas id="unity-canvas" data-pixel-art="true"></canvas>
    
    <script src="Build/Die in the Dungeon 1.6.2f [WEB].loader.js"></script>
    
    <script>
      var canvas = document.querySelector("#unity-canvas");
      var config = {
        dataUrl: "Build/Die in the Dungeon 1.6.2f [WEB].data.gz",
        frameworkUrl: "Build/Die in the Dungeon 1.6.2f [WEB].framework.js", 
        codeUrl: "Build/Die in the Dungeon 1.6.2f [WEB].wasm.gz",
        streamingAssetsUrl: "StreamingAssets",
        companyName: "Die in the Dungeon Team",
        productName: "Die in the Dungeon",
        productVersion: "72f",
      };

      function progressHandler(progress) {
        // Optional: Add loading bar logic here
      }

      // Removed complex resize logic, CSS handles it now
      createUnityInstance(canvas, config, progressHandler).then(function(instance) {
        canvas = instance.Module.canvas;
      });
    </script>
  </div>
</body>
</html>

