<!DOCTYPE html>


<!-- Ultimate Game Stash file--> 
<!-- For the regularly updating doc go to https://docs.google.com/document/d/1_FmH3BlSBQI7FGgAQL59-ZPe8eCxs35wel6JUyVaG8Q/ -->




<html lang="en-us">
 <base href="https://cdn.jsdelivr.net/gh/bubbls/UGS-Assets@main/adventure-capitalist/">
<head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Unity WebGL Player | AdVenture Capitalist!</title>
    <link rel="stylesheet" href="TemplateData/style.css">
    <script src="TemplateData/UnityProgress.js"></script>
    <script src="/js/all.js"></script>

</head>
 
<body class="template">
    <div class="webgl-content">
        <div id="unityContainer" style="width: 960px; height: 600px; padding: 0px; margin: 0px; border: 0px; position: relative; background: rgb(35, 31, 32);">
          
      <canvas class="emscripten" id="canvas" oncontextmenu="event.preventDefault()" width=335 height=667 style="width: 100%; height: 100%; background: #231F20"></canvas>
      
    <div id="loadingBox">
        <div id="bgBar"></div>
        <div id="progressBar"></div>
        <p id="loadingInfo">Loading...</p>
    </div>
    <script>
      window.mergedBlobUrls = {};
      window.assetsReady = false;

      async function mergeSplitFile(fileUrlBase, numParts = 2) {
        const partUrls = Array.from({ length: numParts }, (_, i) => 
          `${fileUrlBase}.part${i + 1}`
        );

        try {
          const responses = await Promise.all(
            partUrls.map(url => fetch(url))
          );

          if (responses.some(r => !r.ok)) {
            return null;
          }

          const parts = await Promise.all(
            responses.map(r => r.arrayBuffer())
          );

          const combinedBlob = new Blob(parts, {
            type: 'application/octet-stream'
          });

          return URL.createObjectURL(combinedBlob);
        } catch (error) {
          return null;
        }
      }

      function setupXHRInterceptor() {
        if (window.xhrInterceptorInstalled) {
          return;
        }
        
        const originalOpen = XMLHttpRequest.prototype.open;
        const originalSend = XMLHttpRequest.prototype.send;

        XMLHttpRequest.prototype.open = function(method, url, ...args) {
          this._url = url;
          this._method = method;
          this._args = args;
          
          let finalUrl = url;
          
          for (const [filename, blobUrl] of Object.entries(window.mergedBlobUrls)) {
            if (url.includes(filename)) {
              finalUrl = blobUrl;
              break;
            }
          }
          
          return originalOpen.call(this, method, finalUrl, ...args);
        };

        XMLHttpRequest.prototype.send = function(...args) {
          const xhr = this;
          
          if (!window.assetsReady) {
            const checkReady = setInterval(() => {
              if (window.assetsReady) {
                clearInterval(checkReady);
                originalSend.apply(xhr, args);
              }
            }, 50);
            return;
          }
          
          return originalSend.apply(this, args);
        };
        
        window.xhrInterceptorInstalled = true;
      }

      async function prepareGameAssets() {
        try {
          window.assetsReady = false;
          delete window.xhrInterceptorInstalled;
          window.mergedBlobUrls = {};
          
          setupXHRInterceptor();
          
          const filesToMerge = [
            { filename: 'Release/webgl.data', parts: 5 },
            { filename: 'Release/webgl.js', parts: 2 }
          ];
          
          for (const file of filesToMerge) {
            const blobUrl = await mergeSplitFile(file.filename, file.parts);
            if (blobUrl) {
              window.mergedBlobUrls[file.filename] = blobUrl;
            }
          }
          
          window.assetsPrepared = true;
          window.assetsReady = true;
          
          initGame();
          
        } catch (error) {
          window.assetsPrepared = false;
          window.assetsReady = true;
          initGame();
        }
      }

      prepareGameAssets();

      function initGame() {
        // connect to canvas
        var Module = {
            TOTAL_MEMORY: 201326592,
            filePackagePrefixURL: "Release/",
            memoryInitializerPrefixURL: "Release/",
            preRun: [],
            postRun: [],
            print: (function() {
                return function(text) {
                    console.log(text);
                };
            })(),
            printErr: function(text) {
                console.error(text);
            },
            canvas: document.getElementById('canvas'),
            progress: null,
            setStatus: function(text) {
                if (this.progress == null) {
                    if (typeof UnityProgress != 'function')
                        return;
                    this.progress = new UnityProgress(canvas);
                }
                if (!Module.setStatus.last) Module.setStatus.last = {
                    time: Date.now(),
                    text: ''
                };
                if (text === Module.setStatus.text) return;
                this.progress.SetMessage(text);
                var m = text.match(/([^(]+)\((\d+(\.\d+)?)\/(\d+)\)/);
                if (m)
                    this.progress.SetProgress(parseInt(m[2]) / parseInt(m[4]));
                if (text === "")
                    this.progress.Clear()
            },
            totalDependencies: 0,
            monitorRunDependencies: function(left) {
                this.totalDependencies = Math.max(this.totalDependencies, left);
                Module.setStatus(left ? 'Preparing... (' + (this.totalDependencies - left) + '/' + this.totalDependencies + ')' : 'All downloads complete.');
            }
        };
        window.Module = Module;
        Module.setStatus('Downloading (0.0/1)');

        // Load UnityConfig.js
        var configScript = document.createElement('script');
        configScript.src = "Release/UnityConfig.js";
        configScript.onload = function() {
          // Load fileloader.js
          var fileloaderScript = document.createElement('script');
          fileloaderScript.src = "Release/fileloader.js";
          fileloaderScript.onload = function() {
            if (!console.logError) {
              console.logError = function () {
                console.error.apply(console, arguments);
              };
            }
            loadWebGL();
          };
          document.body.appendChild(fileloaderScript);
        };
        document.body.appendChild(configScript);
      }

      function loadWebGL() {
        if (!(!Math.fround)) {
          var script = document.createElement('script');
          // Use blob URL if available
          if (window.mergedBlobUrls['Release/webgl.js']) {
            script.src = window.mergedBlobUrls['Release/webgl.js'];
          } else {
            script.src = "Release/webgl.js";
          }
          document.body.appendChild(script);
        } else {
          var codeXHR = new XMLHttpRequest();
          var webglUrl = window.mergedBlobUrls['Release/webgl.js'] || 'Release/webgl.js';
          codeXHR.open('GET', webglUrl, true);
          codeXHR.onload = function() {
            var code = codeXHR.responseText;
            if (!Math.fround) {
              try {
                console.log('optimizing out Math.fround calls');
                var m = /var ([^=]+)=global\.Math\.fround;/.exec(code);
                var minified = m[1];
                if (!minified) throw 'fail';
                var startAsm = code.indexOf('// EMSCRIPTEN_START_FUNCS');
                var endAsm = code.indexOf('// EMSCRIPTEN_END_FUNCS');
                var asm = code.substring(startAsm, endAsm);
                do {
                  var moar = false;
                  asm = asm.replace(new RegExp('[^a-zA-Z0-9\\$\\_]' + minified + '\\(', 'g'), function(s) {
                    moar = true;
                    return s[0] + '('
                  });
                } while (moar);
                code = code.substring(0, startAsm) + asm + code.substring(endAsm);
                code = code.replace("'use asm'", "'almost asm'");
              } catch (e) {
                console.log('failed to optimize out Math.fround calls ' + e)
              }
            }
            var blob = new Blob([code], {
              type: 'text/javascript'
            });
            codeXHR = null;
            var script = document.createElement('script');
            script.src = URL.createObjectURL(blob);
            script.onload = function() {
              URL.revokeObjectURL(script.src);
            };
            document.body.appendChild(script);
          };
          codeXHR.send(null);
        }
      }
    </script>
</body>
 
</html>