<!DOCTYPE html><html lang="en"><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1 user-scalable=no">
    <meta name="author" content="GamePix">
       <base href = "https://cdn.jsdelivr.net/gh/faralong/all@main/wwdd/">
    <style>
        :root {
            --gpx-rt-background: url(background.jpg), linear-gradient(to top, #00395e, #004978);
        }

        html,
        body {
            position: fixed;
            background-color: black;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        * {
            -webkit-touch-callout: none;
            /* iOS Safari */
            -webkit-user-select: none;
            /* Safari */
            -khtml-user-select: none;
            /* Konqueror HTML */
            -moz-user-select: none;
            /* Old versions of Firefox */
            -ms-user-select: none;
            /* Internet Explorer/Edge */
            user-select: none;
            /* Non-prefixed version, currently supported by Chrome, Opera and Firefox */
            -ms-touch-action: none;
            -ms-content-zooming: none;
            touch-action: none;
            outline: none;
        }

        #background {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: linear-gradient(to top, #00395e, #004978);
            background: var(--gpx-rt-background);
            background-size:     cover;
            background-repeat:   no-repeat;
            background-position: center center;
        }
    
    body {
      background: transparent !important;
    }
 
    .gpxForce-bckgr-gamefrm {
      background-image: url(" "), url(" ") !important;
      width: 100%;
      height: 100%;
      -webkit-filter: blur(20px);
      filter: blur(20px);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      background-position: 50% !important;
      background-repeat: no-repeat !important;
      background-size: cover !important;
      position: absolute;
      top: 0;
      left: 0;
      -webkit-transform: scale(1.3);
      transform: scale(1.3);
      z-index: -1;
      opacity: 1;
    }
</style>
    <script>
        const alertFn = window.alert;
        window.alert = (message) => {
            if (message.startsWith("GamePix SDK log:")) {
                console.log(message);
                return;
            }
            alertFn(message);
        };
    </script>
     </head>

<body>
    <div id="background"></div>
    <canvas id="canvas" tabindex="0"></canvas>
   <script src = "jszip.js"></script>
     <script>
      

      
      
  async function fetchAndCombineZip(binUrls) {
    const responses = await Promise.all(binUrls.map(url => fetch(url)));
    const buffers = await Promise.all(responses.map(res => res.arrayBuffer()));
    let totalLength = buffers.reduce((acc, buf) => acc + buf.byteLength, 0);
    let combined = new Uint8Array(totalLength);
    let offset = 0;
    for (let buf of buffers) {
        combined.set(new Uint8Array(buf), offset);
        offset += buf.byteLength;
    }
    return combined;
}

async function unzipWebpFromExternalBins(binUrls) {
    const blobUrls = {};
    const bytes = await fetchAndCombineZip(binUrls);
    const zip = await JSZip.loadAsync(bytes);
    for (const [filename, file] of Object.entries(zip.files)) {
        if (!file.dir) {
            let mime = '';
            if (filename.endsWith('.js') || filename.endsWith('.mjs')) {
                mime = 'text/javascript';
            } else if (filename.endsWith('.css')) {
                mime = 'text/css';
            } else if (filename.endsWith('.html')) {
                mime = 'text/html';
            } else if (filename.endsWith('.webp')) {
                mime = 'image/webp';
            } else if (filename.endsWith('.png')) {
                mime = 'image/png';
            } else if (filename.endsWith('.jpg') || filename.endsWith('.jpeg')) {
                mime = 'image/jpeg';
            }
            const rawBlob = await file.async("blob");
            const blob = mime ? new Blob([rawBlob], { type: mime }) : rawBlob;
            const blobUrl = URL.createObjectURL(blob);
            console.log("Extracted:", filename);
            blobUrls[filename] = blobUrl;
        }
    }
    return blobUrls;
}

let blobUrlss = "";
let binParts = [
  "parts_1.bin",
  "parts_2.bin"
];

unzipWebpFromExternalBins(binParts).then(blobUrls => {
    blobUrlss = blobUrls;
    const ORIGINAL_CREATE_ELEMENT = document.createElement;
    const ORIGINAL_SET_ATTRIBUTE = Element.prototype.setAttribute;

    
    document.createElement = function(tagName) {
        const el = ORIGINAL_CREATE_ELEMENT.call(this, tagName);

        if (tagName.toLowerCase() === 'script') {
            Object.defineProperty(el, 'src', {
                set(newSrc) {
                    const filename = extractFilename(newSrc);
                    const replacement = blobUrlss[filename];
                    if (replacement) {
                        
                        ORIGINAL_SET_ATTRIBUTE.call(el, 'src', replacement);
                    } else {
                        ORIGINAL_SET_ATTRIBUTE.call(el, 'src', newSrc);
                    }
                },
                get() {
                    return el.getAttribute('src');
                },
                configurable: true
            });
        }

        return el;
    };

    
    Element.prototype.setAttribute = function(name, value) {
        if (this.tagName === 'SCRIPT' && name === 'src') {
            const filename = extractFilename(value);
            const replacement = blobUrlss[filename];
            if (replacement) {
             
                return ORIGINAL_SET_ATTRIBUTE.call(this, name, replacement);
            }
        }

        return ORIGINAL_SET_ATTRIBUTE.call(this, name, value);
    };

    function extractFilename(url) {
        try {
            return new URL(url, location.href).pathname.split('/').pop();
        } catch {
            return url.split('/').pop(); 
        }
    }


const imageSrcDescriptor = Object.getOwnPropertyDescriptor(Image.prototype, 'src');
Object.defineProperty(Image.prototype, 'src', {
  set(value) {
    const newURL = rewriteURL(value);
    imageSrcDescriptor.set.call(this, newURL);
  },
  get: imageSrcDescriptor.get,
  configurable: true,
  enumerable: true,
});


const scriptSrcDescriptor = Object.getOwnPropertyDescriptor(HTMLScriptElement.prototype, 'src');
Object.defineProperty(HTMLScriptElement.prototype, 'src', {
  set(value) {
    const newURL = rewriteURL(value);
    scriptSrcDescriptor.set.call(this, newURL);
  },
  get: scriptSrcDescriptor.get,
  configurable: true,
  enumerable: true,
});


const linkHrefDescriptor = Object.getOwnPropertyDescriptor(HTMLLinkElement.prototype, 'href');
Object.defineProperty(HTMLLinkElement.prototype, 'href', {
  set(value) {
    const newURL = rewriteURL(value);
    linkHrefDescriptor.set.call(this, newURL);
  },
  get: linkHrefDescriptor.get,
  configurable: true,
  enumerable: true,
});


const mediaSrcDescriptor = Object.getOwnPropertyDescriptor(HTMLMediaElement.prototype, 'src');
Object.defineProperty(HTMLMediaElement.prototype, 'src', {
  set(value) {
    const newURL = rewriteURL(value);
    mediaSrcDescriptor.set.call(this, newURL);
  },
  get: mediaSrcDescriptor.get,
  configurable: true,
  enumerable: true,
});

// fetch
const originalFetch = window.fetch;
window.fetch = function(resource, init) {

  if (typeof resource === "string") {
  //console.log(resource)
    resource = rewriteURL(resource);
  } else if (resource instanceof Request) {
    resource = new Request(rewriteURL(resource.url), resource);
  }
  return originalFetch.call(this, resource, init);
};

// XMLHttpRequest
const originalOpen = XMLHttpRequest.prototype.open;
XMLHttpRequest.prototype.open = function(method, url, ...rest) {
  const newURL = rewriteURL(url);
  return originalOpen.call(this, method, newURL, ...rest);
};


const OriginalAudio = window.Audio;
window.Audio = function(src) {
  const audio = new OriginalAudio();
  if (src) {
    audio.src = rewriteURL(src);
  }
  return audio;
};
window.Audio.prototype = OriginalAudio.prototype;


function rewriteURL(original) {
if (original.includes("gpx.json")) return "https://cdn.jsdelivr.net/gh/faralong/all@main/wwdd/gpx.json";
  var trimmed = original.split("/").pop();
  //console.log(trimmed)
  if (trimmed.includes("?")) trimmed = trimmed.split("?")[0]
  return blobUrlss[trimmed] || original;
}
	
	
        function getParameterByName(name, url) {
            name = name.replace(/[\[\]]/g, '\\$&');
            const regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)'),
                results = regex.exec(url);
            if (!results) return null;
            if (!results[2]) return '';
            return decodeURIComponent(results[2].replace(/\+/g, ' '));
        };

        if (getParameterByName("autorun", window.location.href) !== "0") {
            const createScript = function() {
                const el = document.createElement("script");
                el.onload = function() {
                    tinyLoader.load();
                };
                el.src = "tiny-loader.js";
                return el;
            }

            const corsScript = createScript();
            corsScript.onerror = function() {
                document.body.removeChild(corsScript);
                const el = createScript();
                el.onerror = console.error;
                document.body.appendChild(el);
            };

            corsScript.setAttribute("crossorigin", "anonymous");
            document.body.appendChild(corsScript);
        }
		
		
		});
    </script>


<div class="gpxForce-bckgr-gamefrm"></div></body></html>